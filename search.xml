<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker for Beginners - Linux</title>
      <link href="/2019/03/19/Docker-for-Beginners-Linux/"/>
      <url>/2019/03/19/Docker-for-Beginners-Linux/</url>
      
        <content type="html"><![CDATA[<h3 id="Step1-先决条件"><a href="#Step1-先决条件" class="headerlink" title="Step1.先决条件"></a>Step1.先决条件</h3><p>​    我们要准备一个用来运行docker容器的服务器，并且要有docker cloud的账号。</p><h3 id="Step2-运行一个简单的docker容器"><a href="#Step2-运行一个简单的docker容器" class="headerlink" title="Step2.运行一个简单的docker容器"></a>Step2.运行一个简单的docker容器</h3><p>​    我们可以执行以下命令来运行一个docker容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run &lt;image name&gt;</span><br></pre></td></tr></table></figure><p>输入指令后，当所执行镜像无法在本地找到时，docker会自动从docker hub上拉取最新的镜像然后执行。</p><p>只要在容器内启动的进程仍在运行，Docker就会使容器保持运行。</p><p>默认情况下，docker不会删除资源，所以进程退出容器停止后处于“已退出”状态。</p><p>​    还可以通过以下命令来查看本地存在的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>​    我们可以通过以下命令来查询远程仓库中的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search &lt;image name&gt;</span><br></pre></td></tr></table></figure><p>​    通过以下命令能够从docker hub上手动拉取所需要的镜像（镜像名后面可以跟镜像标签）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull &lt;image name&gt;[:tag]</span><br></pre></td></tr></table></figure><p>​    以下命令能够列出本地所有的容器（其中包含了上次运行的时间等）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls --all</span><br></pre></td></tr></table></figure><p>1.运行一个交互式的Ubuntu容器，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --interactive --tty --rm ubuntu bash</span><br></pre></td></tr></table></figure><blockquote><ul><li>–interactive 表示你想要一个交互式的会话</li><li>–tty 分配一个伪tty</li></ul><hr><p>以上两个参数使我们能和docker容器进行交互</p><ul><li>–rm 告诉docker在完成执行之后删除容器</li><li>告诉容器运行bash作为其主要进程（PID 1）</li></ul></blockquote><p>当容器启动时，您将使用默认提示符<code>root @ &lt;container id&gt;：/＃</code>进入bash shell。 Docker已附加到容器中的shell，在本地会话和容器中的shell会话之间中继输入和输出。</p><p>接着输入<code>ls /</code>能看到根目录下的所有文件，输入<code>ps aux</code>能够查看Ubuntu容器中在运行的进程，输入<code>cat /etc/issue</code>能够显示Ubuntu容器正在运行的Linux发行版本。</p><p>输入<code>exit</code>命令退出shell会话，这将会终止bash进程，同时由于启动容器时用了<code>--rm</code>标签，所以容器停止后会被docker删除。</p><p>2.运行一个后台的mysql容器，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">--detach \</span><br><span class="line">--name mydb \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=my-secret-pw \</span><br><span class="line">mysql:latest</span><br></pre></td></tr></table></figure><ul><li><code>--detach</code>指会在后台运行</li><li><code>--name</code>指将它命名为mydb</li><li><code>-e</code>指将使用环境变量来指定root密码（注意：绝对不能在生产环境这样做）</li></ul><p>用<code>docker container logs mydb</code>可以查看mysql docker容器的日志</p><p>用<code>docker container top mydb</code>可以查看mysql容器内运行的进程</p><p>使用<code>docker container exec</code>可以查看mysql的版本，具体如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mydb \</span><br><span class="line">mysql --user=root --password=$MYSQL_ROOT_PASSWORD --version</span><br></pre></td></tr></table></figure><p>直接输入以上命令等价于通过<code>docker container exec</code>连接到已经运行的容器中的新shell进程，再查询版本号，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mydb sh</span><br></pre></td></tr></table></figure><p>执行以上命令会提供MySQL容器内的交互式shell（sh），这时候你的shell提示会被修改，表明已经连接到了容器内运行的sh进程。然后再通过相同的命令来检查版本号，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --user=root --password=$MYSQL_ROOT_PASSWORD --version</span><br></pre></td></tr></table></figure><p>结果显示两种方式都是一样的。</p><p>最有键入<code>exit</code>退出交互式会话。</p><h3 id="Step3-使用打包并运行自定义应用程序"><a href="#Step3-使用打包并运行自定义应用程序" class="headerlink" title="Step3.使用打包并运行自定义应用程序"></a>Step3.使用打包并运行自定义应用程序</h3><p>​    使用Dockerfile的形式打包镜像。</p><p>​    首先进入到需要打包的项目目录中，编写Dockerfile文件，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx:latest</span><br><span class="line"></span><br><span class="line">COPY index.html /usr/share/nginx/html</span><br><span class="line">COPY linux.png /usr/share/nginx/html</span><br><span class="line"></span><br><span class="line">EXPOSE 80 443     </span><br><span class="line"></span><br><span class="line">CMD ["nginx", "-g", "daemon off;"]</span><br></pre></td></tr></table></figure><ul><li>FROM：指定要用作正在创建的新镜像的起点的基本镜像。对于这个例子，我们从nginx：latest开始。</li><li>COPY：将文件从Docker主机复制到已知位置的镜像中。在此示例中，COPY用于将两个文件复制到镜像中：index.html。以及将在我们的网页上使用的图片。</li><li>EXPOSE：应用程序使用的端口</li><li>CMD：指定从镜像启动容器时要运行的命令。（注意，我们还可以指定命令以及运行时参数）</li></ul><p>使用<code>docker image build</code>命令使用Dockerfile中的指令创建新的Docker镜像。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build --tag $DOCKERID/linux_tweet_app:1.0 .</span><br></pre></td></tr></table></figure><ul><li><code>--tag</code>允许我们为镜像提供自定义名称。在这种情况下，它由我们的DockerID，应用程序名称和版本组成。将Docker ID附加到名称后，我们可以在稍后的步骤中将其存储在Docker Hub上。</li><li><code>.</code>告诉Docker使用当前目录作为构建上下文</li><li><code>$DOCKERID</code>这个需要我们手动键入命令<code>export DOCKERID=&lt;your docker id&gt;</code>来存储，当然也可以不用dockerid使用其他的值或者不使用</li></ul><p>使用<code>docker container run</code>命令从您创建的映像启动新容器</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">--detach \</span><br><span class="line">--publish 80:80 \</span><br><span class="line">--name linux_tweet_app \</span><br><span class="line"><span class="meta">$</span><span class="bash">DOCKERID/linux_tweet_app:1.0</span></span><br></pre></td></tr></table></figure><p>由于此容器将运行NGINX Web服务器，我们将使用<code>--publish</code>标志将容器内的端口80发布到主机上的端口80上。这将允许进入端口80上的Docker主机的流量被定向到容器中的端口80。 <code>--publish</code>标志的格式是<code>host_port：container_port</code>。</p><p>然后在网页上输入ip和端口遍可以查看到对应的web页。</p><p><strong>删除容器</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm --force linux_tweet_app</span><br></pre></td></tr></table></figure><ul><li>我们使用<code>--force</code>参数删除正在运行的容器而不关闭它。这将不合理地关闭容器并将其从Docker主机中永久删除。</li><li>在生产环境中，大多使用docker container stop来优雅地停止容器并将其保留在主机上。然后使用docker container rm永久删除它。</li></ul><h3 id="Step4-修改正在运行的网站"><a href="#Step4-修改正在运行的网站" class="headerlink" title="Step4.修改正在运行的网站"></a>Step4.修改正在运行的网站</h3><p>​    一般情况下，当我们正在积极处理应用程序时，每次更改源代码时都必须停止容器，重建映像并运行新版本是不方便的。而简化这个过程的一种方法便是将本地计算机上的源代码目录安装到正在运行的容器中。这将允许对主机上的文件所做的任何更改立即反映在容器中。在这里我们使用<code>bind mount</code>来完成。使用绑定装入时，主机上的文件或目录将装入同一主机上运行的容器中。</p><p>举个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">--detach \</span><br><span class="line">--publish 80:80 \</span><br><span class="line">--name linux_tweet_app \</span><br><span class="line">--mount type=bind,source="$(pwd)",target=/usr/share/nginx/html \</span><br><span class="line"><span class="meta">$</span><span class="bash">DOCKERID/linux_tweet_app:1.0</span></span><br></pre></td></tr></table></figure><ul><li>在这个例子中，使用<code>--mount</code>标志将主机上的当前目录挂载到容器内的/usr/share/nginx/html中。</li><li>在Dockerfile中，/usr/share/nginx/html是为Web应用程序存储html文件的位置。</li></ul><p><strong>注意</strong>：确保从Docker主机上的linux_tweet_app目录中运行此命令！</p><p>此时web项目已经启动。</p><p>在这里，我们把一个新的index.html文件内容拷贝到原项目的index.html文件中，或者使用<code>vi</code>对index.html文件内容进行修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp index-new.html index.html</span><br></pre></td></tr></table></figure><p>再去浏览器上刷新页面，就能看到修改之后的页面信息。</p><p>但是，此时如果我们关闭并删除这个容器，然后再通过上面的启动命令启动容器的话，又会回到修改前的页面，这是因为我们之前创建容器时的index.html文件是修改前的。如若我们要使用修改后的index.html页面，那么我们就需要使用<code>docker image build</code>更新一下镜像的版本号，此时再查看本地的镜像便会发现有两个版本的web项目。</p><p>我们还能同时运行创建的两个版本的web工程镜像，不过要注意的是不能再同一个主机使用端口80的两个容器，所以我们可以把一个版本的80端口映射到主机的80端口，另一个版本的80端口映射到主机的8080端口，再修改名字和另一个版本不同即可实现。</p><p><strong>推送镜像到docker hub</strong></p><p>首先需要登录docker hub，使用<code>docker login</code>命令然后按照提示输入账号密码即可。</p><p>然后使用<code>docker image push</code>命令推送到docker hub上，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image push &lt;image name&gt;</span><br></pre></td></tr></table></figure><p>接下来就能再docker hub上查找到你的镜像了。</p>]]></content>
      
      
      <categories>
          
          <category> Docker学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/18/hello-world/"/>
      <url>/2019/03/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
