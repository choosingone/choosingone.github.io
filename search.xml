<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>疯狂Java随笔——面向对象的陷阱</title>
      <link href="/2019/03/27/%E7%96%AF%E7%8B%82Java%E9%9A%8F%E7%AC%94%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%99%B7%E9%98%B1/"/>
      <url>/2019/03/27/%E7%96%AF%E7%8B%82Java%E9%9A%8F%E7%AC%94%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%99%B7%E9%98%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象的陷阱"><a href="#面向对象的陷阱" class="headerlink" title="面向对象的陷阱"></a>面向对象的陷阱</h1><h2 id="非静态内部类的陷阱"><a href="#非静态内部类的陷阱" class="headerlink" title="非静态内部类的陷阱"></a>非静态内部类的陷阱</h2><p>非静态内部类不可能有无参构造器——即使系统为非静态内部类提供了一个默认的构造器，此构造器也需要一个外部类的形参。</p><p><strong>非静态内部类的规则</strong>：非静态内部类必须寄生在外部类的实例中，没有外部类的对象，就不可能产生非静态内部类的对象。</p><p><img src="/疯狂Java随笔——面向对象的陷阱/javap.png" alt></p><p>通过javap反编译可以看到非静态内部类的构造方法的第一个形参一定是外部类。</p><h3 id="static关键词"><a href="#static关键词" class="headerlink" title="static关键词"></a>static关键词</h3><p>静态内部类不能访问外部类的非静态成员</p><h3 id="异常捕捉的陷阱"><a href="#异常捕捉的陷阱" class="headerlink" title="异常捕捉的陷阱"></a>异常捕捉的陷阱</h3><p>在实际开发中, 程序中需要打开一些物理资源：</p><ul><li>数据库连接</li><li>网络连接</li><li>磁盘文件</li></ul><p>这些物理资源需要显式去关闭，否则会引起资源泄漏。</p><p>GC只负责回收堆内存中分配的内存，对于程序中打开的物理资源是无能为力的。</p><p><strong>finally块执行流程的规则：</strong></p><p>当程序执行try块，catch块时遇到throw语句时，throw语句会导致该方法立即结束，系统执行throw语句时并不会立即抛出异常，而是去寻找该异常处理流程是否包含finally块。</p><p>如果没有finally块，程序立即抛出异常，如果有则立即执行finally块。</p><p>只有finally块执行完成才会跳回抛出异常，如果finally块中用return语句来结束方法，系统将不会再跳回try和catch块去抛出异常。</p><p>不要在finally块中递归使用可能引起异常的方法，因为这将导致该方法的异常不能被正常抛出。</p><p><strong>catch</strong></p><p>在try块后使用catch块来捕捉多个异常的时候，要遵循（先处理小异常，后处理大异常）捕捉父类异常的catch块都应排在捕捉子类异常的catch块之后，否则会出现编译异常。</p><p>Java 语言规范规定，子类重写父类方法时，不能声明抛出比父类方法类型更多、范围更大的异常。</p><p>也就是说子类方法只能声明抛出父类方法所声明抛出的异常的子类。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文阅读随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>疯狂Java——Java的内存回收</title>
      <link href="/2019/03/27/%E7%96%AF%E7%8B%82Java%E9%9A%8F%E7%AC%94%E2%80%94%E2%80%94Java%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
      <url>/2019/03/27/%E7%96%AF%E7%8B%82Java%E9%9A%8F%E7%AC%94%E2%80%94%E2%80%94Java%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java的内存回收"><a href="#Java的内存回收" class="headerlink" title="Java的内存回收"></a>Java的内存回收</h1><h2 id="Java引用的种类"><a href="#Java引用的种类" class="headerlink" title="Java引用的种类"></a>Java引用的种类</h2><h3 id="对象在内存中的状态"><a href="#对象在内存中的状态" class="headerlink" title="对象在内存中的状态"></a>对象在内存中的状态</h3><ul><li>可达状态：当一个对象被创建后，有一个以上的引用变量引用它，在有向图中可以从起始顶点导航到该对象，那么它就处于可达状态，程序可通过引用变量来调用该对象的属性和方法。</li><li>可恢复状态：如果程序中某个对象不再有任何引用变量引用它，他将先进入可恢复状态，此时，从有向图的定点不能导航到该对象。在这个状态下，系统的垃圾回收机制准备回收该对象所占用的内存，在回收该对象之前，系统会调用可恢复状态的对象的finalize方法进行资源清理，如果系统在调用finalize方法重新让一个以上的引用变量引用该对象，则这个对象会再次变为可达状态；否则该对象将进入不可达状态。</li><li>不可达状态：当对象的所有关联都被切断，且系统调用所有对象的finalize方法依然没有使该对象变成可达状态，那这个对象j将永久性地失去引用，最后变成不可达状态。只有当一个对象处于不可达状态时，系统才会真正回收该对象所占有的资源。</li></ul><p><img src="/疯狂Java随笔——Java的内存回收/fdnc.png" alt></p><p>对于垃圾回收机制来说，判断一个对象是否可回收的标准就在于该对象是否被引用，因此引用也是JVM进行内存管理的一个重要的概念。Java语言对对象的引用包含强引用，软引用，弱引用，虚引用。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>强引用时Java编程中广泛使用的引用类型，被强引用所引用的对象绝对不会被垃圾回收机制回收，即使系统内存非常紧张，或者有些对象以后永远也不会被用到，这也是造成Java内存泄露的主要原因之一。</p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用需要通过SoftReference类来实现，当一个对象只具有软引用时，它有可能被垃圾回收机制回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;T&gt; softReference = <span class="keyword">new</span> SoftReference[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用需要通过WeakReference类来实现，当一个对象只具有弱引用时，它会被垃圾回收机制回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;T&gt; weadReference = <span class="keyword">new</span> WeakReference&lt;T&gt;(obj);</span><br></pre></td></tr></table></figure><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用不能单独使用，必须和引用队列联合使用。虚引用的主要作用就是跟踪对象被垃圾h回收的状态，程序可以通过检查与虚引用关联的引用队列中是否包含指定的虚引用，从而了解虚引用所引用的对象是否即将被回收。</p><p>当把软引用、弱引用和引用队列联合使用时，系统回收被引用的对象之后，将会把回收对象对应的引用添加到关联的引用队列中；虚引用在对象被释放之前，将把它对应的虚引用添加到它关联的引用队列中，这使得可以在对象被回收之前采取行动。</p><p>虚引用通过PhantomReference类实现，完全类似于没有引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue&lt;T&gt; rq = <span class="keyword">new</span> ReferenceQueue&lt;T&gt;();</span><br><span class="line">PhantomReference&lt;T&gt; pr = <span class="keyword">new</span> PhantomReference&lt;T&gt;(obj , rq);</span><br></pre></td></tr></table></figure><h3 id="Java的内存泄露"><a href="#Java的内存泄露" class="headerlink" title="Java的内存泄露"></a>Java的内存泄露</h3><p>内存泄漏——删除一个对象，但该对象所占用的内存空间却不会释放。</p><p>比如ArrayList的remove(int index)方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>假设定义了一个长度为8的ArrayList，放入了4个值，此时删除最后一个元素，但是并没有执行elementData[–size]==null，那么数组中的第四个元素一直引用内存中原来的对象，那么这个对象将会一直处于可达状态，对于ArrayList而言它的size等于3，但是它却不知道还有第四个元素存在，因此第四个元素永远不会被访问，成为了垃圾，垃圾回收机制也不胡去回收它，这就造成了内存泄漏。</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>作用:</p><ol><li>跟踪并监控每一个Java对象，当某个对象处于不可达状态时，回收该对象所占用的内存。</li><li>清理内存分配，回收过程中产生的内存碎片。</li></ol><h4 id="垃圾回收的基本算法"><a href="#垃圾回收的基本算法" class="headerlink" title="垃圾回收的基本算法"></a>垃圾回收的基本算法</h4><p>对于一个垃圾回收器的设计算法来说，大致有如下可供选择的设计：</p><ul><li>串行回收（Serial）和并行回收（Parallel）：串行回收就是不管系统有几个CPU，始终只用一个CPU来执行垃圾回收操作；并行回收j就是把整个回收工作拆分成多部分，每个部分由一个CPU负责。并行回收执行效率很高，但复杂度增加，另外也有其他一些副作用，比如内存碎片会增加。</li><li>并发执行（Concurrent）和应用程序停止（Stop-the-world）：Stop-the-world的垃圾回收方式在执行垃圾回收的同时会导致应用程序暂停。并发执行的垃圾回收方式虽然不会导致应用程序暂停，但由于兵法执行垃圾回收需要解决和应用程序的执行冲突（应用程序可能在垃圾回收的过程中修改对象），因此并发执行垃圾回收的系统开销比Stop-the-world大，而且需要更多的对内存空间。</li><li>压缩（Compacting）和不压缩（Non-compacting）和复制（Copy）：为了减少内存碎片，支持压缩的垃圾回收器（标记压缩[mark-sweep-compact]*综合了后两种的有点）会把所有的活对象搬到一起，然后把之前占用的内存空间全部回收。不压缩的垃圾回收（标记清楚[mark-sweep]）只是回收内存，但这样回收的内存并不是连续的，所以会有很多的内存碎片。两者比较，不压缩的回收内存快，但是分配内存时更慢，并无法解决内存碎片问题。复制式的垃圾回收会将所有可达对象复制到另一块相同的内存中，然后删除原来的整个内存空间，这样做不会产生内存碎片，但是需要复制数据和额外的内存空间。</li></ul><p>但是现行的垃圾回收器会综合使用多种设计方式。</p><p>现行的垃圾回收器用分代的方式采用不同的回收设计。分代的基本思路是根据对象的生存时间长短把对内存分为3个代：Young（年轻代）、Old（老年代）、Permanent（持久代）</p><h4 id="Young代"><a href="#Young代" class="headerlink" title="Young代"></a>Young代</h4><p>在Young代可以充分发挥复制算法的优点。Young代由一个Eden空间和两个Survivor空间（包括From Space和To Space）组成，其中Survivor空间是用来作为Eden空间和老年代的中间交换区域。绝大多数的对象生成之后会被分配到Eden空间中，然后通过一次垃圾回收将可达状态的对象放入Survivor空间中，并清空Eden空间的对象，Survivor空间中至少有一个空间是空的，用来做数据交换，经过一定次数的垃圾回收仍存活下来的对象会被放入老年代。</p><h4 id="Old代"><a href="#Old代" class="headerlink" title="Old代"></a>Old代</h4><p>Old代的对象是Young代中经过多次垃圾回收仍然存活下来的对象转移而来，Old代中的对象没有那么容易变成不可达状态，所以一般Old代的空间要比Young代要更大。由于Old代的垃圾回收执行频率不用太高，每次执行的时间更长，因此我们通常使用标记压缩算法来设计垃圾回收器，这样可以避免复制大量的对象，也不会产生大量的内存碎片。当Old代中的空间不足时，JVM会在Old代执行完全的垃圾回收（Full GC）。Full GC之后，若Survivor空间和Old代仍然无法存放从Eden转移过来的对象，那么就会导致JVM无法为新生成的对象在Eden空间申请内存，即内存溢出“Out of Memory”。</p><h4 id="Permanent代"><a href="#Permanent代" class="headerlink" title="Permanent代"></a>Permanent代</h4><p>Permanent代主要用于装载Class、方法等信息，垃圾回收器通常不会去回收Permanent代中的对象，对于那些需要加载很多类的服务器程序（比如Spring，hibernate等喜欢AOP动态生成代理类的框架），往往需要加大Permanent代内存，否则可能因为内存不足而导致程序终止。</p><blockquote><p>Java垃圾回收器的附加选项可参考：<a href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a></p></blockquote><h3 id="内存管理小技巧"><a href="#内存管理小技巧" class="headerlink" title="内存管理小技巧"></a>内存管理小技巧</h3><ol><li>尽量使用直接量</li><li>使用StringBuilderj和StringBuffer进行字符串连接</li><li>尽早释放无用对象的引用（如方法在使用完对象后还有耗时耗内存的操作，那就最好在耗时耗内存操作执行前把对象的引用释放掉）</li><li>尽量少用静态变量（因为被static变量所引用的对象生命周期和它所在的类同步，类不被卸载，那么垃圾回收器就不会去回收对象，这就会导致对象一直有效，得不到回收）</li><li>避免在经常调用的方法、循环中创建Java对象</li><li>缓存经常使用的对象</li><li>尽量不要使用finalize方法来执行资源清理（因为在垃圾回收器已经严重制约应用程序性能的情况下，再用finalize方法进行资源清理会造成更大的负担）</li><li>在程序需要创建长度很大的数组时，考虑使用SoftReference来包装数组元素，软引用在内存足够时和普通引用作用一样，内存不够时会释放软引用所引用的对象，这样做的话要注意用显示判断该对象是否为null，当对象为null时重新创建该对象。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术文阅读随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>疯狂Java随笔——对象内存控制</title>
      <link href="/2019/03/22/%E7%96%AF%E7%8B%82Java%E9%9A%8F%E7%AC%94%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/03/22/%E7%96%AF%E7%8B%82Java%E9%9A%8F%E7%AC%94%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="对象内存控制"><a href="#对象内存控制" class="headerlink" title="对象内存控制"></a>对象内存控制</h1><h2 id="static关键词"><a href="#static关键词" class="headerlink" title="static关键词"></a>static关键词</h2><p>修饰类里定义的成员变量，方法，内部类，初始化块，内部枚举类</p><h2 id="类变量的初始化时机"><a href="#类变量的初始化时机" class="headerlink" title="类变量的初始化时机"></a>类变量的初始化时机</h2><p>类变量的初始时机总是在实例变量的初始化时机之前。</p><p>在类的实例化过程中，类中的定义变量语句和初始化块中的语句总是位于类构造器之前执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Price</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Price INSTANCE = <span class="keyword">new</span> Price(<span class="number">2.8</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> initPrice = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">double</span> currentPrice;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Price</span><span class="params">(<span class="keyword">double</span> discount)</span></span>&#123;</span><br><span class="line">        currentPrice = initPrice - discount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Price.INSTANCE.currentPrice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出结果为 -2.8</p><p><img src="//choosingone.github.io/2019/03/22/疯狂Java随笔——对象内存控制/lblcshsj1.png" alt></p><p><img src="//choosingone.github.io/2019/03/22/疯狂Java随笔——对象内存控制/lblcshsj2.png" alt></p><p>通过javap反汇编可以看到，初始化类的时候先给INSTANCE，initPrice两个变量分配了内存空间，此时两者的值为null和0，然后先给INSTANCE赋值时，调用new Price(2.8)，创建Price实例，discount为2.8，此时给currentPrice赋值，但是initPrice的值为0，所以最后得到的currentPrice的值为-2.8。然后程序把initPrice的值赋为20，但这时候对INSTANCE的currentPrice实例变量没用了。但是我们手动再创建一个Price实例时，initPrice是有值的，因此得到的结果会是两者之差。</p><h2 id="调用子类重写的方法"><a href="#调用子类重写的方法" class="headerlink" title="调用子类重写的方法"></a>调用子类重写的方法</h2><p>如果父类构造器调用了被子类重写的方法，并且通过子类构造器来创建子类的对象，（显示或隐式）调用了这个父类构造器，就会导致子类的重写方法在子类构造器的所有代码之前被执行，从而导致子类的重写方法访问不到子类的实例变量值的情形。</p><h2 id="父子实例的内存控制"><a href="#父子实例的内存控制" class="headerlink" title="父子实例的内存控制"></a>父子实例的内存控制</h2><h3 id="继承成员变量和继承方法的区别"><a href="#继承成员变量和继承方法的区别" class="headerlink" title="继承成员变量和继承方法的区别"></a>继承成员变量和继承方法的区别</h3><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wolf</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap反编译得到：</p><p><img src="//choosingone.github.io/2019/03/22/疯狂Java随笔——对象内存控制/fznckz.png" alt></p><p>由此可以看出：</p><ul><li>当Wolf类继承Animal类时，编译器直接将Animal中的void info()方法转移到了Wolf类中。由此可知，若Wolf类也包含了void info()方法，那么编译器就无法将Animal中的void info()方法转移到了Wolf类中。</li><li>对于Animal类中定义的成员变量name，系统任然将其保留在了Animal类中，并没有将其转移到Wolf类中，这使得父类和子类可以同时拥有同名的实例变量。</li><li>因为继承成员变量和继承方法之间存在这样的区别，所以对于一个引用类型的变量而言，通过该变量来访问其所引用的对象的实例变量时，该实例变量的值取决于声明该变量时类型，而通过该变量来调用其所引用的对象的方法时，该方法行为取决于它所实际引用的对象的类型。</li></ul><h3 id="内存中的子类实例"><a href="#内存中的子类实例" class="headerlink" title="内存中的子类实例"></a>内存中的子类实例</h3><p>创建一个子类实例时，内存中实质上只有一个对象被分配内存空间，但是该内存空间中包含了父类的实例变量值。</p><h2 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h2><ol><li>final修饰变量，被final修饰的变量被赋初始值之后，不能对它重新赋值。<ul><li>final修饰实例变量，必须显式指定初始值，而且只能在如下三个位置指定初始值：<ol><li>定义final实例变量时指定初始值</li><li>在非静态初始块代码中为final实例变量指定初始值</li><li>在构造器中为final实例变量指定初始值</li></ol></li><li>final修饰类变量，必须显式指定初始值，而且只能在如下三个位置指定初始值：<ol><li>定义final类变量时指定初始值</li><li>在静态初始块代码中为final实例变量指定初始值</li></ol></li><li>final修饰的变量在定义时就指定了初始值，而且这个初始值在编译时就可以定下来，那么这个变量会被当做“宏变量”处理。</li><li>字符串缓存池会把曾使用过的字符串直接量进行缓存，之后再定义相同的字符串就会执行“宏替换”，把字符串变量指向缓存池中的值。</li><li>Java在局部内部类（包含匿名内部类）中使用的局部变量，必须使用final修饰（因为内部类可能产生隐式闭包，这将会使局部变量脱离它所在的方法继续存在）</li></ul></li><li>final修饰方法，被final修饰的方法不能被重写。（*Java中用@Override注解修饰的方法必须覆写原来的方法）</li><li>final修饰类，被final修饰的类不能被继承。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术文阅读随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>疯狂Java随笔——数组内存控制</title>
      <link href="/2019/03/22/%E7%96%AF%E7%8B%82Java%E9%9A%8F%E7%AC%94%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/03/22/%E7%96%AF%E7%8B%82Java%E9%9A%8F%E7%AC%94%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h1><p>数组的初始化指代的是引用对象的初始化，而非引用变量的初始化。数组对象的初始化是为了给该对象分配一块连续的堆内存空间，此内存空间的长度也就是数组的长度，而数组变量是为了引用对象的。</p><p><strong>在Java程序中的所有引用变量都不需要进行初始化操作，需要进行初始化操作的是该引用变量所引用的对象。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术文阅读随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker for Beginners - Linux</title>
      <link href="/2019/03/19/Docker-for-Beginners-Linux/"/>
      <url>/2019/03/19/Docker-for-Beginners-Linux/</url>
      
        <content type="html"><![CDATA[<h3 id="Step1-先决条件"><a href="#Step1-先决条件" class="headerlink" title="Step1.先决条件"></a>Step1.先决条件</h3><p>​    我们要准备一个用来运行docker容器的服务器，并且要有docker cloud的账号。</p><h3 id="Step2-运行一个简单的docker容器"><a href="#Step2-运行一个简单的docker容器" class="headerlink" title="Step2.运行一个简单的docker容器"></a>Step2.运行一个简单的docker容器</h3><p>​    我们可以执行以下命令来运行一个docker容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run &lt;image name&gt;</span><br></pre></td></tr></table></figure><p>输入指令后，当所执行镜像无法在本地找到时，docker会自动从docker hub上拉取最新的镜像然后执行。</p><p>只要在容器内启动的进程仍在运行，Docker就会使容器保持运行。</p><p>默认情况下，docker不会删除资源，所以进程退出容器停止后处于“已退出”状态。</p><p>​    还可以通过以下命令来查看本地存在的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>​    我们可以通过以下命令来查询远程仓库中的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search &lt;image name&gt;</span><br></pre></td></tr></table></figure><p>​    通过以下命令能够从docker hub上手动拉取所需要的镜像（镜像名后面可以跟镜像标签）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull &lt;image name&gt;[:tag]</span><br></pre></td></tr></table></figure><p>​    以下命令能够列出本地所有的容器（其中包含了上次运行的时间等）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls --all</span><br></pre></td></tr></table></figure><p>1.运行一个交互式的Ubuntu容器，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --interactive --tty --rm ubuntu bash</span><br></pre></td></tr></table></figure><blockquote><ul><li>–interactive 表示你想要一个交互式的会话</li><li>–tty 分配一个伪tty</li></ul><hr><p>以上两个参数使我们能和docker容器进行交互</p><ul><li>–rm 告诉docker在完成执行之后删除容器</li><li>告诉容器运行bash作为其主要进程（PID 1）</li></ul></blockquote><p>当容器启动时，您将使用默认提示符<code>root @ &lt;container id&gt;：/＃</code>进入bash shell。 Docker已附加到容器中的shell，在本地会话和容器中的shell会话之间中继输入和输出。</p><p>接着输入<code>ls /</code>能看到根目录下的所有文件，输入<code>ps aux</code>能够查看Ubuntu容器中在运行的进程，输入<code>cat /etc/issue</code>能够显示Ubuntu容器正在运行的Linux发行版本。</p><p>输入<code>exit</code>命令退出shell会话，这将会终止bash进程，同时由于启动容器时用了<code>--rm</code>标签，所以容器停止后会被docker删除。</p><p>2.运行一个后台的mysql容器，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">--detach \</span><br><span class="line">--name mydb \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=my-secret-pw \</span><br><span class="line">mysql:latest</span><br></pre></td></tr></table></figure><ul><li><code>--detach</code>指会在后台运行</li><li><code>--name</code>指将它命名为mydb</li><li><code>-e</code>指将使用环境变量来指定root密码（注意：绝对不能在生产环境这样做）</li></ul><p>用<code>docker container logs mydb</code>可以查看mysql docker容器的日志</p><p>用<code>docker container top mydb</code>可以查看mysql容器内运行的进程</p><p>使用<code>docker container exec</code>可以查看mysql的版本，具体如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mydb \</span><br><span class="line">mysql --user=root --password=$MYSQL_ROOT_PASSWORD --version</span><br></pre></td></tr></table></figure><p>直接输入以上命令等价于通过<code>docker container exec</code>连接到已经运行的容器中的新shell进程，再查询版本号，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mydb sh</span><br></pre></td></tr></table></figure><p>执行以上命令会提供MySQL容器内的交互式shell（sh），这时候你的shell提示会被修改，表明已经连接到了容器内运行的sh进程。然后再通过相同的命令来检查版本号，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --user=root --password=$MYSQL_ROOT_PASSWORD --version</span><br></pre></td></tr></table></figure><p>结果显示两种方式都是一样的。</p><p>最有键入<code>exit</code>退出交互式会话。</p><h3 id="Step3-使用打包并运行自定义应用程序"><a href="#Step3-使用打包并运行自定义应用程序" class="headerlink" title="Step3.使用打包并运行自定义应用程序"></a>Step3.使用打包并运行自定义应用程序</h3><p>​    使用Dockerfile的形式打包镜像。</p><p>​    首先进入到需要打包的项目目录中，编写Dockerfile文件，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx:latest</span><br><span class="line"></span><br><span class="line">COPY index.html /usr/share/nginx/html</span><br><span class="line">COPY linux.png /usr/share/nginx/html</span><br><span class="line"></span><br><span class="line">EXPOSE 80 443     </span><br><span class="line"></span><br><span class="line">CMD ["nginx", "-g", "daemon off;"]</span><br></pre></td></tr></table></figure><ul><li>FROM：指定要用作正在创建的新镜像的起点的基本镜像。对于这个例子，我们从nginx：latest开始。</li><li>COPY：将文件从Docker主机复制到已知位置的镜像中。在此示例中，COPY用于将两个文件复制到镜像中：index.html。以及将在我们的网页上使用的图片。</li><li>EXPOSE：应用程序使用的端口</li><li>CMD：指定从镜像启动容器时要运行的命令。（注意，我们还可以指定命令以及运行时参数）</li></ul><p>使用<code>docker image build</code>命令使用Dockerfile中的指令创建新的Docker镜像。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build --tag $DOCKERID/linux_tweet_app:1.0 .</span><br></pre></td></tr></table></figure><ul><li><code>--tag</code>允许我们为镜像提供自定义名称。在这种情况下，它由我们的DockerID，应用程序名称和版本组成。将Docker ID附加到名称后，我们可以在稍后的步骤中将其存储在Docker Hub上。</li><li><code>.</code>告诉Docker使用当前目录作为构建上下文</li><li><code>$DOCKERID</code>这个需要我们手动键入命令<code>export DOCKERID=&lt;your docker id&gt;</code>来存储，当然也可以不用dockerid使用其他的值或者不使用</li></ul><p>使用<code>docker container run</code>命令从您创建的映像启动新容器</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">--detach \</span><br><span class="line">--publish 80:80 \</span><br><span class="line">--name linux_tweet_app \</span><br><span class="line"><span class="meta">$</span><span class="bash">DOCKERID/linux_tweet_app:1.0</span></span><br></pre></td></tr></table></figure><p>由于此容器将运行NGINX Web服务器，我们将使用<code>--publish</code>标志将容器内的端口80发布到主机上的端口80上。这将允许进入端口80上的Docker主机的流量被定向到容器中的端口80。 <code>--publish</code>标志的格式是<code>host_port：container_port</code>。</p><p>然后在网页上输入ip和端口遍可以查看到对应的web页。</p><p><strong>删除容器</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm --force linux_tweet_app</span><br></pre></td></tr></table></figure><ul><li>我们使用<code>--force</code>参数删除正在运行的容器而不关闭它。这将不合理地关闭容器并将其从Docker主机中永久删除。</li><li>在生产环境中，大多使用docker container stop来优雅地停止容器并将其保留在主机上。然后使用docker container rm永久删除它。</li></ul><h3 id="Step4-修改正在运行的网站"><a href="#Step4-修改正在运行的网站" class="headerlink" title="Step4.修改正在运行的网站"></a>Step4.修改正在运行的网站</h3><p>​    一般情况下，当我们正在积极处理应用程序时，每次更改源代码时都必须停止容器，重建映像并运行新版本是不方便的。而简化这个过程的一种方法便是将本地计算机上的源代码目录安装到正在运行的容器中。这将允许对主机上的文件所做的任何更改立即反映在容器中。在这里我们使用<code>bind mount</code>来完成。使用绑定装入时，主机上的文件或目录将装入同一主机上运行的容器中。</p><p>举个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">--detach \</span><br><span class="line">--publish 80:80 \</span><br><span class="line">--name linux_tweet_app \</span><br><span class="line">--mount type=bind,source="$(pwd)",target=/usr/share/nginx/html \</span><br><span class="line"><span class="meta">$</span><span class="bash">DOCKERID/linux_tweet_app:1.0</span></span><br></pre></td></tr></table></figure><ul><li>在这个例子中，使用<code>--mount</code>标志将主机上的当前目录挂载到容器内的/usr/share/nginx/html中。</li><li>在Dockerfile中，/usr/share/nginx/html是为Web应用程序存储html文件的位置。</li></ul><p><strong>注意</strong>：确保从Docker主机上的linux_tweet_app目录中运行此命令！</p><p>此时web项目已经启动。</p><p>在这里，我们把一个新的index.html文件内容拷贝到原项目的index.html文件中，或者使用<code>vi</code>对index.html文件内容进行修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp index-new.html index.html</span><br></pre></td></tr></table></figure><p>再去浏览器上刷新页面，就能看到修改之后的页面信息。</p><p>但是，此时如果我们关闭并删除这个容器，然后再通过上面的启动命令启动容器的话，又会回到修改前的页面，这是因为我们之前创建容器时的index.html文件是修改前的。如若我们要使用修改后的index.html页面，那么我们就需要使用<code>docker image build</code>更新一下镜像的版本号，此时再查看本地的镜像便会发现有两个版本的web项目。</p><p>我们还能同时运行创建的两个版本的web工程镜像，不过要注意的是不能再同一个主机使用端口80的两个容器，所以我们可以把一个版本的80端口映射到主机的80端口，另一个版本的80端口映射到主机的8080端口，再修改名字和另一个版本不同即可实现。</p><p><strong>推送镜像到docker hub</strong></p><p>首先需要登录docker hub，使用<code>docker login</code>命令然后按照提示输入账号密码即可。</p><p>然后使用<code>docker image push</code>命令推送到docker hub上，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image push &lt;image name&gt;</span><br></pre></td></tr></table></figure><p>接下来就能再docker hub上查找到你的镜像了。</p>]]></content>
      
      
      <categories>
          
          <category> Docker学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/18/hello-world/"/>
      <url>/2019/03/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
