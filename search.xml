<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>疯狂Java随笔——对象内存控制</title>
      <link href="/2019/03/22/%E7%96%AF%E7%8B%82Java%E9%9A%8F%E7%AC%94%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/03/22/%E7%96%AF%E7%8B%82Java%E9%9A%8F%E7%AC%94%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="对象内存控制"><a href="#对象内存控制" class="headerlink" title="对象内存控制"></a>对象内存控制</h1><h2 id="static关键词"><a href="#static关键词" class="headerlink" title="static关键词"></a>static关键词</h2><p>修饰类里定义的成员变量，方法，内部类，初始化块，内部枚举类</p><h2 id="类变量的初始化时机"><a href="#类变量的初始化时机" class="headerlink" title="类变量的初始化时机"></a>类变量的初始化时机</h2><p>类变量的初始时机总是在实例变量的初始化时机之前。</p><p>在类的实例化过程中，类中的定义变量语句和初始化块中的语句总是位于类构造器之前执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Price</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Price INSTANCE = <span class="keyword">new</span> Price(<span class="number">2.8</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> initPrice = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">double</span> currentPrice;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Price</span><span class="params">(<span class="keyword">double</span> discount)</span></span>&#123;</span><br><span class="line">        currentPrice = initPrice - discount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Price.INSTANCE.currentPrice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出结果为 -2.8</p><p><img src="//choosingone.github.io/2019/03/22/疯狂Java随笔——对象内存控制/hexo\myblog\source\_posts\lblcshsj1.png" alt></p><p><img src="//choosingone.github.io/2019/03/22/疯狂Java随笔——对象内存控制/hexo\myblog\source\_posts\lblcshsj2.png" alt></p><p>通过javap反汇编可以看到，初始化类的时候先给INSTANCE，initPrice两个变量分配了内存空间，此时两者的值为null和0，然后先给INSTANCE赋值时，调用new Price(2.8)，创建Price实例，discount为2.8，此时给currentPrice赋值，但是initPrice的值为0，所以最后得到的currentPrice的值为-2.8。然后程序把initPrice的值赋为20，但这时候对INSTANCE的currentPrice实例变量没用了。但是我们手动再创建一个Price实例时，initPrice是有值的，因此得到的结果会是两者之差。</p><h2 id="调用子类重写的方法"><a href="#调用子类重写的方法" class="headerlink" title="调用子类重写的方法"></a>调用子类重写的方法</h2><p>如果父类构造器调用了被子类重写的方法，并且通过子类构造器来创建子类的对象，（显示或隐式）调用了这个父类构造器，就会导致子类的重写方法在子类构造器的所有代码之前被执行，从而导致子类的重写方法访问不到子类的实例变量值的情形。</p><h2 id="父子实例的内存控制"><a href="#父子实例的内存控制" class="headerlink" title="父子实例的内存控制"></a>父子实例的内存控制</h2><h3 id="继承成员变量和继承方法的区别"><a href="#继承成员变量和继承方法的区别" class="headerlink" title="继承成员变量和继承方法的区别"></a>继承成员变量和继承方法的区别</h3><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wolf</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap反编译得到：</p><p><img src="//choosingone.github.io/2019/03/22/疯狂Java随笔——对象内存控制/hexo\myblog\source\_posts\fznckz.png" alt></p><p>由此可以看出：</p><ul><li>当Wolf类继承Animal类时，编译器直接将Animal中的void info()方法转移到了Wolf类中。由此可知，若Wolf类也包含了void info()方法，那么编译器就无法将Animal中的void info()方法转移到了Wolf类中。</li><li>对于Animal类中定义的成员变量name，系统任然将其保留在了Animal类中，并没有将其转移到Wolf类中，这使得父类和子类可以同时拥有同名的实例变量。</li><li>因为继承成员变量和继承方法之间存在这样的区别，所以对于一个引用类型的变量而言，通过该变量来访问其所引用的对象的实例变量时，该实例变量的值取决于声明该变量时类型，而通过该变量来调用其所引用的对象的方法时，该方法行为取决于它所实际引用的对象的类型。</li></ul><h3 id="内存中的子类实例"><a href="#内存中的子类实例" class="headerlink" title="内存中的子类实例"></a>内存中的子类实例</h3><p>创建一个子类实例时，内存中实质上只有一个对象被分配内存空间，但是该内存空间中包含了父类的实例变量值。</p><h2 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h2><ol><li>final修饰变量，被final修饰的变量被赋初始值之后，不能对它重新赋值。<ul><li>final修饰实例变量，必须显式指定初始值，而且只能在如下三个位置指定初始值：<ol><li>定义final实例变量时指定初始值</li><li>在非静态初始块代码中为final实例变量指定初始值</li><li>在构造器中为final实例变量指定初始值</li></ol></li><li>final修饰类变量，必须显式指定初始值，而且只能在如下三个位置指定初始值：<ol><li>定义final类变量时指定初始值</li><li>在静态初始块代码中为final实例变量指定初始值</li></ol></li><li>final修饰的变量在定义时就指定了初始值，而且这个初始值在编译时就可以定下来，那么这个变量会被当做“宏变量”处理。</li><li>字符串缓存池会把曾使用过的字符串直接量进行缓存，之后再定义相同的字符串就会执行“宏替换”，把字符串变量指向缓存池中的值。</li><li>Java在局部内部类（包含匿名内部类）中使用的局部变量，必须使用final修饰（因为内部类可能产生隐式闭包，这将会使局部变量脱离它所在的方法继续存在）</li></ul></li><li>final修饰方法，被final修饰的方法不能被重写。（*Java中用@Override注解修饰的方法必须覆写原来的方法）</li><li>final修饰类，被final修饰的类不能被继承。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术文阅读随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>疯狂Java随笔——数组内存控制</title>
      <link href="/2019/03/22/%E7%96%AF%E7%8B%82Java%E9%9A%8F%E7%AC%94%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/03/22/%E7%96%AF%E7%8B%82Java%E9%9A%8F%E7%AC%94%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h1><p>数组的初始化指代的是引用对象的初始化，而非引用变量的初始化。数组对象的初始化是为了给该对象分配一块连续的堆内存空间，此内存空间的长度也就是数组的长度，而数组变量是为了引用对象的。</p><p><strong>在Java程序中的所有引用变量都不需要进行初始化操作，需要进行初始化操作的是该引用变量所引用的对象。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术文阅读随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker for Beginners - Linux</title>
      <link href="/2019/03/19/Docker-for-Beginners-Linux/"/>
      <url>/2019/03/19/Docker-for-Beginners-Linux/</url>
      
        <content type="html"><![CDATA[<h3 id="Step1-先决条件"><a href="#Step1-先决条件" class="headerlink" title="Step1.先决条件"></a>Step1.先决条件</h3><p>​    我们要准备一个用来运行docker容器的服务器，并且要有docker cloud的账号。</p><h3 id="Step2-运行一个简单的docker容器"><a href="#Step2-运行一个简单的docker容器" class="headerlink" title="Step2.运行一个简单的docker容器"></a>Step2.运行一个简单的docker容器</h3><p>​    我们可以执行以下命令来运行一个docker容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run &lt;image name&gt;</span><br></pre></td></tr></table></figure><p>输入指令后，当所执行镜像无法在本地找到时，docker会自动从docker hub上拉取最新的镜像然后执行。</p><p>只要在容器内启动的进程仍在运行，Docker就会使容器保持运行。</p><p>默认情况下，docker不会删除资源，所以进程退出容器停止后处于“已退出”状态。</p><p>​    还可以通过以下命令来查看本地存在的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>​    我们可以通过以下命令来查询远程仓库中的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search &lt;image name&gt;</span><br></pre></td></tr></table></figure><p>​    通过以下命令能够从docker hub上手动拉取所需要的镜像（镜像名后面可以跟镜像标签）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull &lt;image name&gt;[:tag]</span><br></pre></td></tr></table></figure><p>​    以下命令能够列出本地所有的容器（其中包含了上次运行的时间等）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls --all</span><br></pre></td></tr></table></figure><p>1.运行一个交互式的Ubuntu容器，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --interactive --tty --rm ubuntu bash</span><br></pre></td></tr></table></figure><blockquote><ul><li>–interactive 表示你想要一个交互式的会话</li><li>–tty 分配一个伪tty</li></ul><hr><p>以上两个参数使我们能和docker容器进行交互</p><ul><li>–rm 告诉docker在完成执行之后删除容器</li><li>告诉容器运行bash作为其主要进程（PID 1）</li></ul></blockquote><p>当容器启动时，您将使用默认提示符<code>root @ &lt;container id&gt;：/＃</code>进入bash shell。 Docker已附加到容器中的shell，在本地会话和容器中的shell会话之间中继输入和输出。</p><p>接着输入<code>ls /</code>能看到根目录下的所有文件，输入<code>ps aux</code>能够查看Ubuntu容器中在运行的进程，输入<code>cat /etc/issue</code>能够显示Ubuntu容器正在运行的Linux发行版本。</p><p>输入<code>exit</code>命令退出shell会话，这将会终止bash进程，同时由于启动容器时用了<code>--rm</code>标签，所以容器停止后会被docker删除。</p><p>2.运行一个后台的mysql容器，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">--detach \</span><br><span class="line">--name mydb \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=my-secret-pw \</span><br><span class="line">mysql:latest</span><br></pre></td></tr></table></figure><ul><li><code>--detach</code>指会在后台运行</li><li><code>--name</code>指将它命名为mydb</li><li><code>-e</code>指将使用环境变量来指定root密码（注意：绝对不能在生产环境这样做）</li></ul><p>用<code>docker container logs mydb</code>可以查看mysql docker容器的日志</p><p>用<code>docker container top mydb</code>可以查看mysql容器内运行的进程</p><p>使用<code>docker container exec</code>可以查看mysql的版本，具体如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mydb \</span><br><span class="line">mysql --user=root --password=$MYSQL_ROOT_PASSWORD --version</span><br></pre></td></tr></table></figure><p>直接输入以上命令等价于通过<code>docker container exec</code>连接到已经运行的容器中的新shell进程，再查询版本号，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mydb sh</span><br></pre></td></tr></table></figure><p>执行以上命令会提供MySQL容器内的交互式shell（sh），这时候你的shell提示会被修改，表明已经连接到了容器内运行的sh进程。然后再通过相同的命令来检查版本号，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --user=root --password=$MYSQL_ROOT_PASSWORD --version</span><br></pre></td></tr></table></figure><p>结果显示两种方式都是一样的。</p><p>最有键入<code>exit</code>退出交互式会话。</p><h3 id="Step3-使用打包并运行自定义应用程序"><a href="#Step3-使用打包并运行自定义应用程序" class="headerlink" title="Step3.使用打包并运行自定义应用程序"></a>Step3.使用打包并运行自定义应用程序</h3><p>​    使用Dockerfile的形式打包镜像。</p><p>​    首先进入到需要打包的项目目录中，编写Dockerfile文件，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx:latest</span><br><span class="line"></span><br><span class="line">COPY index.html /usr/share/nginx/html</span><br><span class="line">COPY linux.png /usr/share/nginx/html</span><br><span class="line"></span><br><span class="line">EXPOSE 80 443     </span><br><span class="line"></span><br><span class="line">CMD ["nginx", "-g", "daemon off;"]</span><br></pre></td></tr></table></figure><ul><li>FROM：指定要用作正在创建的新镜像的起点的基本镜像。对于这个例子，我们从nginx：latest开始。</li><li>COPY：将文件从Docker主机复制到已知位置的镜像中。在此示例中，COPY用于将两个文件复制到镜像中：index.html。以及将在我们的网页上使用的图片。</li><li>EXPOSE：应用程序使用的端口</li><li>CMD：指定从镜像启动容器时要运行的命令。（注意，我们还可以指定命令以及运行时参数）</li></ul><p>使用<code>docker image build</code>命令使用Dockerfile中的指令创建新的Docker镜像。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build --tag $DOCKERID/linux_tweet_app:1.0 .</span><br></pre></td></tr></table></figure><ul><li><code>--tag</code>允许我们为镜像提供自定义名称。在这种情况下，它由我们的DockerID，应用程序名称和版本组成。将Docker ID附加到名称后，我们可以在稍后的步骤中将其存储在Docker Hub上。</li><li><code>.</code>告诉Docker使用当前目录作为构建上下文</li><li><code>$DOCKERID</code>这个需要我们手动键入命令<code>export DOCKERID=&lt;your docker id&gt;</code>来存储，当然也可以不用dockerid使用其他的值或者不使用</li></ul><p>使用<code>docker container run</code>命令从您创建的映像启动新容器</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">--detach \</span><br><span class="line">--publish 80:80 \</span><br><span class="line">--name linux_tweet_app \</span><br><span class="line"><span class="meta">$</span><span class="bash">DOCKERID/linux_tweet_app:1.0</span></span><br></pre></td></tr></table></figure><p>由于此容器将运行NGINX Web服务器，我们将使用<code>--publish</code>标志将容器内的端口80发布到主机上的端口80上。这将允许进入端口80上的Docker主机的流量被定向到容器中的端口80。 <code>--publish</code>标志的格式是<code>host_port：container_port</code>。</p><p>然后在网页上输入ip和端口遍可以查看到对应的web页。</p><p><strong>删除容器</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm --force linux_tweet_app</span><br></pre></td></tr></table></figure><ul><li>我们使用<code>--force</code>参数删除正在运行的容器而不关闭它。这将不合理地关闭容器并将其从Docker主机中永久删除。</li><li>在生产环境中，大多使用docker container stop来优雅地停止容器并将其保留在主机上。然后使用docker container rm永久删除它。</li></ul><h3 id="Step4-修改正在运行的网站"><a href="#Step4-修改正在运行的网站" class="headerlink" title="Step4.修改正在运行的网站"></a>Step4.修改正在运行的网站</h3><p>​    一般情况下，当我们正在积极处理应用程序时，每次更改源代码时都必须停止容器，重建映像并运行新版本是不方便的。而简化这个过程的一种方法便是将本地计算机上的源代码目录安装到正在运行的容器中。这将允许对主机上的文件所做的任何更改立即反映在容器中。在这里我们使用<code>bind mount</code>来完成。使用绑定装入时，主机上的文件或目录将装入同一主机上运行的容器中。</p><p>举个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">--detach \</span><br><span class="line">--publish 80:80 \</span><br><span class="line">--name linux_tweet_app \</span><br><span class="line">--mount type=bind,source="$(pwd)",target=/usr/share/nginx/html \</span><br><span class="line"><span class="meta">$</span><span class="bash">DOCKERID/linux_tweet_app:1.0</span></span><br></pre></td></tr></table></figure><ul><li>在这个例子中，使用<code>--mount</code>标志将主机上的当前目录挂载到容器内的/usr/share/nginx/html中。</li><li>在Dockerfile中，/usr/share/nginx/html是为Web应用程序存储html文件的位置。</li></ul><p><strong>注意</strong>：确保从Docker主机上的linux_tweet_app目录中运行此命令！</p><p>此时web项目已经启动。</p><p>在这里，我们把一个新的index.html文件内容拷贝到原项目的index.html文件中，或者使用<code>vi</code>对index.html文件内容进行修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp index-new.html index.html</span><br></pre></td></tr></table></figure><p>再去浏览器上刷新页面，就能看到修改之后的页面信息。</p><p>但是，此时如果我们关闭并删除这个容器，然后再通过上面的启动命令启动容器的话，又会回到修改前的页面，这是因为我们之前创建容器时的index.html文件是修改前的。如若我们要使用修改后的index.html页面，那么我们就需要使用<code>docker image build</code>更新一下镜像的版本号，此时再查看本地的镜像便会发现有两个版本的web项目。</p><p>我们还能同时运行创建的两个版本的web工程镜像，不过要注意的是不能再同一个主机使用端口80的两个容器，所以我们可以把一个版本的80端口映射到主机的80端口，另一个版本的80端口映射到主机的8080端口，再修改名字和另一个版本不同即可实现。</p><p><strong>推送镜像到docker hub</strong></p><p>首先需要登录docker hub，使用<code>docker login</code>命令然后按照提示输入账号密码即可。</p><p>然后使用<code>docker image push</code>命令推送到docker hub上，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image push &lt;image name&gt;</span><br></pre></td></tr></table></figure><p>接下来就能再docker hub上查找到你的镜像了。</p>]]></content>
      
      
      <categories>
          
          <category> Docker学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/18/hello-world/"/>
      <url>/2019/03/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
